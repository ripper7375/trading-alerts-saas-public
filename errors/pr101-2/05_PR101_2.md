The failing job is due to test failures in **tests**/api/indicators.test.ts, specifically related to the GET /api/indicators/[symbol]/[timeframe] endpoint. The test expects the endpoint to return a 500 status and a specific error message ('MT5 service error' or 'Internal server error') when certain errors are thrown by the MT5 service layer.

After reviewing the test and the corresponding route handler in app/api/indicators/[symbol]/[timeframe]/route.ts (ref: 83294c3b4e872a10c8c4e5c3d83776ad29a03825):

- The tests for handling MT5ServiceError and unexpected errors (lines 435–459 and 487–507 in the test file) expect the API to return 500 with specific error message strings in the response.
- The route handler does return status 500 with those error messages when these exceptions are caught.

Common causes for these tests to fail include:

- The error thrown from mockFetchIndicatorData might not be correctly caught as an instance of MT5ServiceError or Error.
- The test mock or handler may not be using consistent error class definitions due to module duplication or misconfiguration in jest.mock.

**Solution:**

1. Ensure that the MT5ServiceError, MT5AccessDeniedError classes used in the test and in the route handler are referencing the exact same instance. If Jest module mocks lead to multiple copies of the error class, use Object.getPrototypeOf(error).constructor.name or error.name to check error types, or consolidate error classes through a single import source in both test and route file.

2. In app/api/indicators/[symbol]/[timeframe]/route.ts, adjust error type checks in the catch block:

   ```typescript
   // Replace `error instanceof MT5ServiceError`:
   if (error instanceof MT5ServiceError || error?.name === 'MT5ServiceError') {
     //...
   }
   ```

   Similarly, handle unknown errors with:

   ```typescript
   if (error instanceof Error || error?.name === 'Error') {
     //...
   }
   ```

3. Double check that the mock in the test file is used for all imports in the handler via jest.mock, to prevent mock class mismatch.

4. If the above does not resolve, log the error type and stack in both the handler and the test for more details.

By ensuring consistent error class usage and checking error types more robustly, the test should pass and the job should succeed.

- [View test file](https://github.com/ripper7375/trading-alerts-saas-public/blob/83294c3b4e872a10c8c4e5c3d83776ad29a03825/__tests__/api/indicators.test.ts)
- [View route handler](https://github.com/ripper7375/trading-alerts-saas-public/blob/83294c3b4e872a10c8c4e5c3d83776ad29a03825/app/api/indicators/[symbol]/[timeframe]/route.ts)

Apply these changes in ref 83294c3b4e872a10c8c4e5c3d83776ad29a03825.
