I'll analyze the failing job to find a solution for you. The job is failing due to 4 test failures in the `PaymentOrchestrator` tests. Let me examine the test file and the implementation to understand the issue: ## Solution for Failing Tests

The test failures are caused by a **status validation issue** in the `PaymentOrchestrator. executeBatch()` method. When `retryFailedTransactions()` is called, it updates the batch status to `QUEUED` and then calls `executeBatch()`, but the batch still has a `FAILED` status in memory during the test execution.

### Root Cause

Looking at line 267 in the test file, the mock batch has `status: 'FAILED'`:

```typescript
const mockBatch = {
  id:  'batch-123',
  batchNumber: 'BATCH-2024-001',
  status: 'FAILED',  // This causes the validation error
  // ...
```

When `retryFailedTransactions` updates the status to `QUEUED` (line 340 in payment-orchestrator.ts), it then calls `executeBatch` which fetches the batch again. However, the mock in the test returns the same batch object with `status: 'FAILED'`, causing the validation check at lines 66-69 to fail.

### Fix

Update the mock in `__tests__/lib/disbursement/services/orchestrator.test.ts` at **line 287** to return a batch with `PENDING` status after the status update:

```typescript
it('should retry failed transactions in a batch', async () => {
  const mockBatch = {
    id: 'batch-123',
    batchNumber: 'BATCH-2024-001',
    status: 'FAILED',
    transactions: [
      {
        id: 'txn-1',
        transactionId: 'TXN-123',
        status: 'PENDING',
        payeeRiseId: '0xA35b.. .',
        commissionId: 'comm-1',
        amount: 50. 0,
        currency: 'USD',
        commission: { id: 'comm-1', status: 'APPROVED' },
        affiliateRiseAccount: { affiliateProfileId: 'aff-123' },
      },
    ],
    auditLogs: [],
  };

  // Mock reset for retry
  mockPrisma.disbursementTransaction. updateMany = jest.fn().mockResolvedValue({ count: 1 });

  // Mock batch lookup - return FAILED first, then QUEUED after update
  mockPrisma.paymentBatch.findUnique = jest.fn()
    .mockResolvedValueOnce(mockBatch) // First call in retryFailedTransactions
    . mockResolvedValueOnce({ ... mockBatch, status: 'QUEUED' }); // Second call in executeBatch

  mockPrisma.paymentBatch.count = jest.fn().mockResolvedValue(0);
  mockPrisma.paymentBatch.update = jest.fn().mockResolvedValue({});
  mockPrisma.disbursementTransaction.update = jest.fn().mockResolvedValue({});
  mockPrisma.commission.update = jest.fn().mockResolvedValue({});
  mockPrisma.disbursementAuditLog.create = jest. fn().mockResolvedValue({});

  const result = await orchestrator.retryFailedTransactions('batch-123');

  expect(result.batchId).toBe('batch-123');
});
```

The key change is using `mockResolvedValueOnce` to return different values for sequential calls to `findUnique` - first with `FAILED` status, then with `QUEUED` status after the update.
