Below are focused fixes for each TypeScript error from job 58582925497 and concrete code suggestions you can apply. After making these changes run tsc --noEmit locally or re-run the CI job.

1. TS4111 — app/admin/affiliates/[id]/page.tsx (params.id)

- Problem: useParams() returns an index-signature type so dot-access (params.id) triggers TS4111.
- Solution: access via bracket notation or narrow the type. Replace the current lines with one of these safe options.

Option A — bracket access (minimal change)

```ts
const params = useParams();
const affiliateId = params['id'] as string;
```

Option B — narrow type (safer if you want strict typing)

```ts
const params = useParams() as { [key: string]: string | undefined };
const affiliateId = params['id']!;
```

File link (for context):
https://github.com/ripper7375/trading-alerts-saas-public/blob/76fdad15afeaab92920b39f7b4a8dc16120a4f04/app/admin/affiliates/[id]/page.tsx

2. TS6133 — app/api/admin/affiliates/[id]/reactivate/route.ts and app/api/admin/affiliates/[id]/route.ts (unused request parameter)

- Problem: the Request parameter is declared but not used in the handler.
- Solution: remove the parameter or mark it unused by prefixing with underscore.

Example: if your handler currently is:

```ts
export async function POST(request: Request) {
  // no use of request
  ...
}
```

Change to either:

```ts
export async function POST() {
  ...
}
```

or

```ts
export async function POST(_: Request) {
  ...
}
```

3. TS2532 — app/api/admin/affiliates/reports/commission-owings/route.ts (Object is possibly 'undefined')

- Problem: code is accessing a property on a value that might be undefined.
- Solution: add a guard or use optional chaining/defaults before using the value.

Example guard:

```ts
if (!someObj) {
  return new Response('Not found', { status: 404 });
}
// safe to access someObj.prop
const value = someObj.prop;
```

Or use optional chaining where appropriate:

```ts
const total = someObj?.amount ?? 0;
```

If you expect the object to exist but TypeScript cannot prove it, add an explicit runtime check and narrow the type, or narrow the type assertion:

```ts
if (!records) throw new Error('Missing records');
const amount = records[0].amount;
```

4. TS2322 — app/api/admin/commissions/pay/route.ts (status property type mismatch)

- Problem: building a Prisma/typed where input using a plain string for status; Prisma expects either the enum type or a filter object.
- Solution: either cast to the enum type from @prisma/client or use a filter object with equals. Prefer importing the enum type and typing the where object.

Option A — use the enum from Prisma:

```ts
import type { CommissionStatus } from '@prisma/client';

// ...

const where = {
  affiliateProfileId,
  status: 'PENDING' as CommissionStatus,
  ...(ids?.length ? { id: { in: ids } } : undefined),
};
```

Option B — use the Enum filter shape:

```ts
const where = {
  affiliateProfileId,
  status: { equals: 'PENDING' }, // matches EnumCommissionStatusFilter shape
  ...(ids?.length ? { id: { in: ids } } : undefined),
};
```

Either approach satisfies the type expected by CommissionWhereInput.

5. TS4111 — lib/admin/affiliate-management.ts (index-signature property access)

- Problem: code uses dot notation to access properties that come from an index signature.
- Solution: use bracket notation (or narrow the variable type).

Example replace:

```ts
const status = row.status;
const country = row.country;
const paymentMethod = row.paymentMethod;
```

with:

```ts
const status = row['status'];
const country = row['country'];
const paymentMethod = row['paymentMethod'];
```

Or, if you control the upstream type, define a typed interface for the row so dot-access is allowed:

```ts
interface AffiliateRow {
  status: string;
  country: string;
  paymentMethod: string;
  // ...
}
const row = data as AffiliateRow;
```

General notes

- For all "property comes from an index signature" errors prefer either bracket notation or giving the variable an explicit typed shape (interface) so dot access is allowed.
- For unused parameters, prefer removing them. If they are intentionally present for future use, prefix with underscore to silence TS6133.
- For Prisma enum fields, prefer importing the enum types from @prisma/client or use the filter object form (status: { equals: 'VALUE' }) instead of raw string values.
- Re-run TypeScript check after applying the above fixes: tsc --noEmit

If you want, I can produce exact patch diffs for each file (with the commit ref 76fdad15afeaab92920b39f7b4a8dc16120a4f04) showing the minimal edits to make these TypeScript errors go away.
