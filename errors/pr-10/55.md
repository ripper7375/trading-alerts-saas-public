Summary

- The test failure comes from **tests**/api/affiliate-dashboard.test.ts expecting the codes API to return the requested page and limit in the response (data.page === 2, data.limit === 10). The route currently returns a response without the requested pagination values (or it does not parse the query params correctly), so data.page/data.limit are not the expected values and the assertion fails.

Root cause

- The GET handler for app/api/affiliate/dashboard/codes/route does not parse and return the page/limit query parameters (or calculates skip/take incorrectly). The test constructs the request URL with ?page=2&limit=10 via a MockRequest whose nextUrl is a URL object, and then asserts that the response includes page and limit and that prisma.findMany is called with skip: 10, take: 10. The handler must:
  1. Parse page and limit from request.nextUrl.searchParams (fallback to sensible defaults).
  2. Calculate skip = (page - 1) \* limit and take = limit.
  3. Include page and limit in the JSON response.

Code fix (recommended)

- Update app/api/affiliate/dashboard/codes/route.ts to explicitly parse page & limit, compute skip/take, and include page & limit in the returned JSON. Example implementation:

File: app/api/affiliate/dashboard/codes/route.ts
Ref: af657dbc09201f8407979c70b2804a1a2523ebc6
Suggested replacement / patch (TypeScript):

```ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/db/prisma';
import { requireAffiliate, getAffiliateProfile } from '@/lib/auth/session';

export async function GET(request: Request) {
  try {
    // enforce affiliate session (adjust depending on your requireAffiliate API)
    const session = await requireAffiliate();
    const affiliateProfile = await getAffiliateProfile(session.user.id);
    if (!affiliateProfile) {
      return NextResponse.json({ code: 'PROFILE_NOT_FOUND' }, { status: 404 });
    }

    // get URL/search params - tests set request.nextUrl = new URL(...)
    // use nextUrl when available for Next.js Request mocks
    // fall back to new URL(request.url) for safety
    const url = (request as any).nextUrl ?? new URL(request.url);

    // parse pagination params
    const pageParam = url.searchParams.get('page') ?? '1';
    const limitParam = url.searchParams.get('limit') ?? '25';

    const page = Math.max(1, Number.parseInt(pageParam, 10) || 1);
    const limit = Math.max(1, Number.parseInt(limitParam, 10) || 25);

    // optional: clamp limit to reasonable max
    const MAX_LIMIT = 100;
    const normalizedLimit = Math.min(limit, MAX_LIMIT);

    // build where clause (support status filter used by tests)
    const status = url.searchParams.get('status') || undefined;
    const where: any = { affiliateProfileId: affiliateProfile.id };
    if (status) where.status = status;

    // compute skip/take for prisma
    const skip = (page - 1) * normalizedLimit;
    const take = normalizedLimit;

    const [codes, total] = await Promise.all([
      prisma.affiliateCode.findMany({
        where,
        orderBy: { distributedAt: 'desc' },
        skip,
        take,
      }),
      prisma.affiliateCode.count({ where }),
    ]);

    return NextResponse.json({
      codes,
      total,
      page,
      limit: normalizedLimit,
    });
  } catch (err: any) {
    // map expected auth errors to test assertions
    if (err?.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    if (err?.message === 'AFFILIATE_REQUIRED') {
      return NextResponse.json({ code: 'AFFILIATE_REQUIRED' }, { status: 403 });
    }

    // generic error
    return NextResponse.json({ code: 'CODES_ERROR' }, { status: 500 });
  }
}
```

Why this fixes the failing test

- The test constructs the request URL with ?page=2&limit=10 and expects:
  - the response to include page: 2 and limit: 10
  - prisma.findMany to be called with skip: 10 and take: 10
- The suggested code reads page & limit from request.nextUrl.searchParams, calculates skip=(page-1)\*limit, uses take=limit, and returns page & limit in the response. That will satisfy the test assertions.

Notes / validation

- After applying the change, run the test suite:
  - npm test (or the project's test command)
  - Focused run: run only the failing test suite to iterate quickly:
    - e.g. jest **tests**/api/affiliate-dashboard.test.ts -i
- If you used a different default limit in your app, adjust the default value to match expectations (the test expects the provided limit to be returned verbatim when supplied).
- The test's MockRequest sets request.nextUrl, so the handler must read request.nextUrl (or fall back to new URL(request.url)). The provided code handles both.

If this route already contains parsing but still fails

- Verify that:
  - The handler actually returns the page & limit fields in the JSON body (tests call response.json()).
  - Numbers are returned (not strings). Tests use toBe(2) so expect numeric values.
  - skip/take are computed from numeric page/limit and not from strings (i.e., ensure parseInt/Number is used).
  - The handler is calling prisma.findMany with skip and take as numbers (mockAffiliateCodeFindMany is asserted against an objectContaining with skip/take).
- If your handler uses a helper for parsing pagination, ensure that it supports request.nextUrl (or accepts Request and extracts URL correctly); your test mock uses nextUrl.

Relevant test file (for reference): **tests**/api/affiliate-dashboard.test.ts

- Link (using job ref): https://github.com/ripper7375/trading-alerts-saas-public/blob/af657dbc09201f8407979c70b2804a1a2523ebc6/__tests__/api/affiliate-dashboard.test.ts

Implementing the provided code change should resolve the failing test by ensuring pagination parameters are parsed, used for skip/take, and returned in the API response.
