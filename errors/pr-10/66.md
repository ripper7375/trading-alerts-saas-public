Summary

- The failing CI job (ID 58539515531) fails one test in **tests**/api/affiliate-dashboard.test.ts — the pagination test for GET /api/affiliate/dashboard/codes. The assertion expecting page=2 (and skip/take to be set) fails.
- Root cause (most likely): the API route for /api/affiliate/dashboard/codes is not reading/using query parameters correctly (page/limit/status) or is not returning page and limit in the response. The tests assert the route must:
  - parse page and limit from request.nextUrl.searchParams,
  - compute skip = (page-1)\*limit and take = limit and pass those to prisma.affiliateCode.findMany,
  - include page and limit in the JSON response,
  - include status in the where clause when provided.
- Fix: update the route implementation to defensively parse query params, build the where object properly, call prisma.findMany with skip/take, call prisma.count with the same where, and return { codes, total, page, limit }.

Suggested implementation (replace or update app/api/affiliate/dashboard/codes/route.ts)

- Example TypeScript Next.js route handler that satisfies the tests:

```ts
// File: app/api/affiliate/dashboard/codes/route.ts
import { NextResponse } from 'next/server';
import { requireAffiliate, getAffiliateProfile } from '@/lib/auth/session';
import { prisma } from '@/lib/db/prisma';

export async function GET(request: Request) {
  try {
    // requireAffiliate throws if not authenticated / not affiliate
    await requireAffiliate();

    const profile = await getAffiliateProfile();
    if (!profile) {
      return NextResponse.json({ code: 'PROFILE_NOT_FOUND' }, { status: 404 });
    }

    const url = (request as any).nextUrl ?? new URL((request as Request).url);
    const params = url.searchParams;

    // Parse pagination params safely
    const parsePositiveInt = (val: string | null, fallback: number) => {
      if (!val) return fallback;
      const n = Number(val);
      if (!Number.isFinite(n) || n < 1) return fallback;
      return Math.floor(n);
    };

    const page = parsePositiveInt(params.get('page'), 1);
    const limit = parsePositiveInt(params.get('limit'), 25);

    // Status filter
    const status = params.get('status') ?? undefined;

    const where: any = {
      affiliateProfileId: profile.id,
    };
    if (status) {
      where.status = status;
    }

    // Compute skip/take for pagination
    const skip = (page - 1) * limit;
    const take = limit;

    const [codes, total] = await Promise.all([
      prisma.affiliateCode.findMany({
        where,
        skip,
        take,
        orderBy: { distributedAt: 'desc' },
      }),
      prisma.affiliateCode.count({ where }),
    ]);

    // If you need to convert Date objects to ISO strings for JSON:
    const normalizedCodes = codes.map((c) => ({
      ...c,
      distributedAt: c.distributedAt
        ? new Date(c.distributedAt).toISOString()
        : null,
      expiresAt: c.expiresAt ? new Date(c.expiresAt).toISOString() : null,
      usedAt: c.usedAt ? new Date(c.usedAt).toISOString() : null,
    }));

    return NextResponse.json(
      {
        codes: normalizedCodes,
        total,
        page,
        limit,
      },
      { status: 200 }
    );
  } catch (err: any) {
    // requireAffiliate throws different errors in tests: 'Unauthorized' and 'AFFILIATE_REQUIRED'
    if (err?.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    if (err?.message === 'AFFILIATE_REQUIRED') {
      return NextResponse.json({ code: 'AFFILIATE_REQUIRED' }, { status: 403 });
    }

    console.error('Affiliate codes route error', err);
    return NextResponse.json({ code: 'CODES_ERROR' }, { status: 500 });
  }
}
```

Why this fixes the failing test

- Parses page & limit robustly (tests send ?page=2&limit=10).
- Computes skip = 10 and take = 10 when page=2 & limit=10, satisfying assertions like:
  expect(mockAffiliateCodeFindMany).toHaveBeenCalledWith(expect.objectContaining({ skip: 10, take: 10 }));
- Returns page and limit in the response body, so test assertions expecting data.page and data.limit pass.
- Includes the status filter in the where object, satisfying the "filter codes by status" test.
- Uses the same where object for count(), so total matches test expectations.

Additional defensive notes and quick checks

- Ensure the route reads request.nextUrl (the tests mock Request.nextUrl via the MockRequest). If you use new URL(request.url) be careful—MockRequest already sets nextUrl so prefer request.nextUrl when available: const url = (request as any).nextUrl ?? new URL(request.url).
- Be careful with parseInt/Number fallback: avoid using (Number(val) || default) because Number('0') becomes 0 and falsy — use Number.isFinite checks.
- Make sure the route returns a top-level page and limit numeric fields rather than embedding them in a pagination object (tests expect top-level page/limit for codes route).
- If you transform Date fields, ensure normalized output matches test expectations; tests in this suite only inspect length/total/page/limit and don't assert exact date format for codes list, but normalization is useful.

Where to apply the patch

- Update the file at:
  https://github.com/ripper7375/trading-alerts-saas-public/blob/af657dbc09201f8407979c70b2804a1a2523ebc6/app/api/affiliate/dashboard/codes/route.ts
  (use that ref when committing your change to the branch used by CI).

Run tests locally after the change:

- npm test or yarn test (the project’s test command) — re-run the affiliate-dashboard tests to confirm the pagination tests pass.
- If other tests fail related to response shape, adjust the response keys to match what tests expect.

If you want, I can:

- Produce a minimal patch/PR diff for the file above to apply the changes exactly.
- Inspect the current route file and adapt the patch to the existing code (I’ll need access to the route file contents).
