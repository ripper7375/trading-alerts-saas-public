Summary of failures (from job 58537130888, ref 35f091b00b5fdcc3403020d2470fdeb8e98d81dc)

- Two test suites failed: **tests**/api/affiliate-conversion.test.ts and **tests**/api/affiliate-dashboard.test.ts.
- The affiliate-conversion suite shows a failing test for "should normalize code to uppercase" (test expects prisma.findUnique called with where.code === 'LOWER123').
- The logs and tests also show a failing expiry-boundary assertion: tests expect an expiresAt that is exactly "now" to be treated as expired.
- The affiliate-dashboard test expects a 401 when unauthenticated.

Root causes (based on tests and logs)

1. The validate-code route is not normalizing the incoming code to uppercase before querying prisma. The test explicitly checks that prisma.findUnique is called with where: { code: 'LOWER123' } when the request code was 'lower123'.
2. The expiry check in the validate-code route treats expiresAt < now as expired, but the tests expect expiresAt === now to be considered expired as well (i.e., expiry should be inclusive: treat expiresAt <= now as expired).
3. An API route that should guard with authentication (affiliate dashboard codes) is returning a non-401 response when no auth is present (route must return 401 when unauthenticated).

Concrete fixes and code suggestions

1. Normalize incoming code to uppercase and trim before querying prisma
   Update app/api/checkout/validate-code/route.ts to normalize the code early. Replace the code-reading logic with something like:

// Normalize and validate incoming code
const body = await request.json();
const rawCode = (body?.code ?? '').toString();
const code = rawCode.trim().toUpperCase();

if (!code) {
return NextResponse.json({ valid: false, code: 'CODE_REQUIRED' }, { status: 400 });
}

Then use the normalized code in the prisma query:

const affiliateCode = await prisma.affiliateCode.findUnique({
where: { code }, // <- use uppercase 'code'
include: { affiliateProfile: true },
});

This ensures mockAffiliateCodeFindUnique will be called with where.code === 'LOWER123' when request provided 'lower123'.

2. Make expiry check inclusive (expiresAt <= now => expired)
   Change expiry logic so codes whose expiresAt equals the current time are considered expired. Example:

const now = new Date();
// expiresAt may be a Date or a string depending on prisma setup -- coerce accordingly
const expiresAt = affiliateCode?.expiresAt ? new Date(affiliateCode.expiresAt) : null;

if (!expiresAt || now >= expiresAt) {
return NextResponse.json(
{ valid: false, code: 'CODE_EXPIRED', message: 'This code has expired.' },
{ status: 400 }
);
}

Note: use now >= expiresAt (or now.getTime() >= expiresAt.getTime()) to treat exact-boundary as expired (test expects expiry at exactly now to fail).

3. Ensure non-active statuses are rejected with CODE_NOT_ACTIVE and clear message
   Make sure you handle code statuses that are not ACTIVE (USED, CANCELLED, EXPIRED, etc.):

if (affiliateCode.status !== 'ACTIVE') {
return NextResponse.json(
{
valid: false,
code: 'CODE_NOT_ACTIVE',
message: `This code has ${affiliateCode.status.toLowerCase()}.`,
},
{ status: 400 }
);
}

4. Return 401 when unauthenticated in affiliate dashboard route
   Edit the affiliate dashboard GET route (app/api/affiliate/dashboard/codes or the corresponding route under app/api/affiliate/dashboard) to explicitly check the authentication/session and return 401 when missing:

// pseudo-example
const user = await getCurrentUser(); // however your app gets session
if (!user) {
return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
}

This will satisfy the test that expects a 401 response when not authenticated.

5. Ensure NextResponse.json usage is consistent
   Tests mock NextResponse.json to return an object with a status field. Make sure all returns use NextResponse.json(payload, { status: <code> }) rather than custom response objects so tests pick up the status correctly.

6. Recalculate discount values precisely (if any rounding mismatch)
   The tests assert discount.amount === 5.8 and finalPrice === 23.2 (20% of 29). Ensure discount math uses consistent rounding (e.g., Number((basePrice \* percent / 100).toFixed(2))). Example:

const basePrice = AFFILIATE_CONFIG.BASE_PRICE_USD; // e.g. 29.0
const percent = affiliateCode.discountPercent;
const amount = Number(((basePrice \* percent) / 100).toFixed(2));
const finalPrice = Number((basePrice - amount).toFixed(2));

Return these in the response object exactly as tests expect.

## Example minimal patch for validate-code route (illustrative â€” adapt to your file structure and existing code):

const { POST } = async (request) => {
try {
const body = await request.json();
const rawCode = (body?.code ?? '').toString();
const code = rawCode.trim().toUpperCase();

    if (!code) {
      return NextResponse.json({ valid: false, code: 'CODE_REQUIRED' }, { status: 400 });
    }

    const affiliateCode = await prisma.affiliateCode.findUnique({
      where: { code },
      include: { affiliateProfile: true },
    });

    if (!affiliateCode) {
      return NextResponse.json({ valid: false, code: 'CODE_NOT_FOUND' }, { status: 404 });
    }

    if (affiliateCode.status !== 'ACTIVE') {
      return NextResponse.json(
        { valid: false, code: 'CODE_NOT_ACTIVE', message: `This code has ${affiliateCode.status.toLowerCase()}.` },
        { status: 400 }
      );
    }

    const now = new Date();
    const expiresAt = affiliateCode.expiresAt ? new Date(affiliateCode.expiresAt) : null;
    if (!expiresAt || now >= expiresAt) {
      return NextResponse.json({ valid: false, code: 'CODE_EXPIRED' }, { status: 400 });
    }

    // compute discount
    const basePrice = AFFILIATE_CONFIG.BASE_PRICE_USD;
    const percent = affiliateCode.discountPercent;
    const amount = Number(((basePrice * percent) / 100).toFixed(2));
    const finalPrice = Number((basePrice - amount).toFixed(2));

    return NextResponse.json({
      valid: true,
      code: affiliateCode.code,
      affiliateId: affiliateCode.affiliateProfileId ?? affiliateCode.affiliateProfile?.id,
      discount: { percent, amount, regularPrice: basePrice, finalPrice },
      message: `${percent}% discount applied.`,
    }, { status: 200 });

} catch (error) {
console.error('[ValidateCode] Error:', error);
return NextResponse.json({ valid: false, code: 'VALIDATION_ERROR' }, { status: 500 });
}
};

---

What to run after changes

- Run the unit tests just for the failing suite to validate the fixes:
  - **tests**/api/affiliate-conversion.test.ts
  - **tests**/api/affiliate-dashboard.test.ts
- If passing, run full test suite / CI.

References (from job logs and test file)

- Failing job ref: 35f091b00b5fdcc3403020d2470fdeb8e98d81dc
- Test file inspected: **tests**/api/affiliate-conversion.test.ts (ref 35f091b00b5fdcc3403020d2470fdeb8e98d81dc)

If you want, I can produce a ready patch (diff) for the specific route files (app/api/checkout/validate-code/route.ts and the affiliate dashboard route) based on the snippets above.
