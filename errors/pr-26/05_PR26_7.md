I'll analyze the failing job to find a solution. Let me start by getting the logs. I can see two test failures. Let me examine the failing test files to understand what's happening: ## Solution for Failing Tests

You have 2 failing tests in your payment orchestration feature:

### 1. **orchestrator.test.ts** - Line 129 failure

**Issue**: `expect(result.successCount).toBe(2)` is failing, meaning the orchestrator isn't returning the expected success count.

**Root Cause**: The test expects 2 successful payments, but the mock implementation likely isn't properly tracking successful payment processing.

**Fix** - Check your `PaymentOrchestrator` implementation:

```typescript
// In lib/disbursement/services/payment-orchestrator.ts
// Ensure you're properly counting successful transactions:

async executeBatch(batchId: string) {
  // ...  existing code ...

  let successCount = 0;
  let failedCount = 0;
  const errors: any[] = [];

  for (const transaction of batch.transactions) {
    try {
      const result = await this.processTransaction(transaction);
      if (result.success) {
        successCount++; // Make sure this is incremented
      } else {
        failedCount++;
        errors.push(result.error);
      }
    } catch (error) {
      failedCount++;
      errors.push(error);
    }
  }

  return {
    success: failedCount === 0,
    batchId,
    successCount,
    failedCount,
    totalAmount: batch.totalAmount,
    errors,
  };
}
```

### 2. **batches/route.test.ts** - Line 134 failure

**Issue**: The test at line 134 expects status 200, but likely getting a different status code.

**Root Cause**: Looking at line 134, the test is checking `expect(response.status).toBe(200)` after filtering by status query param, but the route implementation may not be handling the response correctly.

**Fix** - In `app/api/disbursement/batches/route.ts`:

```typescript
export async function GET(request: NextRequest) {
  try {
    await requireAdmin();

    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status');

    const batchManager = new BatchManager(prisma);
    const batches = await batchManager.getAllBatches();

    // Filter by status if provided
    const filteredBatches = status
      ? batches.filter((b) => b.status === status)
      : batches;

    return NextResponse.json(
      { batches: filteredBatches },
      { status: 200 } // Ensure explicit 200 status
    );
  } catch (error) {
    if (error instanceof AuthError) {
      return NextResponse.json(
        { error: error.message },
        { status: error.statusCode }
      );
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**Key Points**:

- Verify your `PaymentOrchestrator. executeBatch()` properly counts and returns `successCount` and `failedCount`
- Ensure your GET route returns explicit `{ status: 200 }` in the NextResponse
- Both tests are expecting successful execution paths with proper status tracking
