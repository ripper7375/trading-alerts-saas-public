Your failing job is caused by multiple end-to-end (E2E) test failures in **tests**/e2e/dlocal-payment-flow.test.ts. The main error is:

> Matcher error: received value must not be null nor undefined  
> Received has value: undefined

This means the tested code expects a value (likely from an API or function call) for several country payment flows, but it is receiving undefined.

### Solution Steps

1. **Check Payment Flow Mocks**  
   Ensure all tests mocking payment provider responses (especially for IN, NG, PK, VN, ID, TH, ZA, TR) are actually returning the expected value. Likely, the mock or stub is missing or not supplying the needed payload.

   Example:

   ```ts
   // If you are using jest.mock or a similar mock setup:
   jest
     .spyOn(paymentProvider, 'fetchExchangeRate')
     .mockResolvedValue(expectedRateObject);
   ```

   Make sure this exists for each country tested.

2. **Check API / Database Responses**  
   If the code interacts with external APIs or a test DB, make sure all required fixtures or fake data for these currencies/countries are present.

3. **Add Null Checks**  
   To aid debugging and prevent immediate failure, add an explicit null/undefined check before your `.toContain` or similar calls:

   ```ts
   expect(received).not.toBeNull();
   expect(received).not.toBeUndefined();
   expect(received).toContain(expected);
   ```

4. **Review Fallback/Failure Handling in Code**  
   Logs like:
   ```
   [WARN] Failed to fetch exchange rate from API, using fallback rate
   ```
   suggest that your code is defaulting to a fallbackâ€”ensure this fallback provides all required fields, or adapt your test to accept the fallback.

### Actionable Fix Example

If the error is in a function like fetchExchangeRate (or similar), ensure your stub/mock for each currency always returns a valid object, not undefined:

```ts
beforeEach(() => {
  jest
    .spyOn(paymentProvider, 'fetchExchangeRate')
    .mockImplementation((currency) => {
      // map of test responses
      const rates = {
        IN: {
          /* valid rate for IN */
        },
        NG: {
          /* valid rate for NG */
        },
        // etc
      };
      return Promise.resolve(rates[currency] || { rate: 1 });
    });
});
```

### Summary

- Fix the mocks for payment/exchange rate APIs so they never return undefined.
- Add explicit checks for null/undefined in your tests for better errors.
- Make sure your fallbacks in app code return the correct structure.

Let me know if you want direct links to the affected test lines or specific code references in your repo.
